"""Schematic catalog for divine construction.

Loads the catalog index generated by the data pipeline and provides
browse/inspect/build/search functionality for the LLM gods.
"""

import json
import logging
import re
from pathlib import Path

logger = logging.getLogger("minecraft-god")

_catalog: dict | None = None
_catalog_path = Path(__file__).parent.parent / "scripts" / "schematics" / "schematics" / "catalog.json"


def _load_catalog():
    """Load the schematic catalog from disk (lazy, cached)."""
    global _catalog
    if _catalog is not None:
        return _catalog
    if not _catalog_path.exists():
        logger.warning(f"Schematic catalog not found: {_catalog_path}")
        _catalog = {"categories": {}}
        return _catalog
    with open(_catalog_path) as f:
        _catalog = json.load(f)
    total = sum(c.get("count", len(c.get("blueprints", []))) for c in _catalog["categories"].values())
    logger.info(f"Schematic catalog loaded: {total} blueprints across {len(_catalog['categories'])} categories")
    return _catalog


def browse_schematics(category: str) -> str:
    """Browse the schematic catalog. Returns formatted text for the LLM.

    If category is "all" or empty, returns category list with counts.
    Otherwise, returns blueprints in that category.
    """
    catalog = _load_catalog()

    if not category or category == "all":
        # Return category overview
        lines = ["Available schematic categories:"]
        for cat_name in sorted(catalog["categories"]):
            cat_data = catalog["categories"][cat_name]
            count = cat_data.get("count", len(cat_data.get("blueprints", [])))
            lines.append(f"  {cat_name}: {count} blueprints")
        lines.append("\nUse browse_schematics with a specific category to see available blueprints.")
        return "\n".join(lines)

    # Find the category
    if category not in catalog["categories"]:
        # Try partial match
        matches = [c for c in catalog["categories"] if category in c]
        if len(matches) == 1:
            category = matches[0]
        elif matches:
            return f"Multiple categories match '{category}': {', '.join(matches)}. Be more specific."
        else:
            available = ", ".join(sorted(catalog["categories"]))
            return f"Category '{category}' not found. Available: {available}"

    cat_data = catalog["categories"][category]
    blueprints = cat_data.get("blueprints", [])
    lines = [f"Category '{category}' — {len(blueprints)} blueprints:\n"]
    for bp in blueprints:
        d = bp["dimensions"]
        lines.append(f"  {bp['id']}: {bp['name']} ({d['w']}x{d['h']}x{d['d']}, {bp['block_count']} blocks)")
    lines.append(f"\nUse inspect_schematic with a blueprint ID to see details, or build_schematic to construct one.")
    return "\n".join(lines)


def search_schematics(query: str) -> str:
    """Fuzzy search across all schematics by name, tags, and description.

    Returns top 10 results ranked by relevance, formatted for the LLM.
    Much faster than browsing categories when the player asks for something specific.
    """
    catalog = _load_catalog()
    query = query.strip().lower()
    if not query:
        return "Please provide a search query (e.g. 'iron farm', 'sugar cane', 'storage system')."

    # Split query into individual terms for multi-word matching
    terms = query.split()

    results = []  # (score, category, blueprint)

    for cat_name, cat_data in catalog["categories"].items():
        for bp in cat_data.get("blueprints", []):
            score = _score_match(bp, cat_name, terms, query)
            if score > 0:
                results.append((score, cat_name, bp))

    if not results:
        return (f"No schematics found matching '{query}'. "
                f"Try broader terms, or use browse_schematics('all') to see categories.")

    # Sort by score descending, take top 10
    results.sort(key=lambda r: -r[0])
    top = results[:10]

    lines = [f"Search results for '{query}' ({len(results)} matches, showing top {len(top)}):\n"]
    for score, cat_name, bp in top:
        d = bp["dimensions"]
        dl = bp.get("downloads", 0)
        dl_str = f", {dl} downloads" if dl else ""
        lines.append(
            f"  {bp['id']}: {bp['name']}\n"
            f"    category: {cat_name} | {d['w']}x{d['h']}x{d['d']}{dl_str}"
        )
    lines.append(f"\nUse inspect_schematic for details, or build_schematic to construct one directly.")
    return "\n".join(lines)


def _score_match(bp: dict, category: str, terms: list[str], full_query: str) -> float:
    """Score a blueprint against search terms. Higher = better match."""
    name = bp.get("name", "").lower()
    tags = [t.lower() for t in bp.get("tags", [])]
    desc = bp.get("description", "").lower()
    bp_id = bp.get("id", "").lower()
    downloads = bp.get("downloads", 0)

    score = 0.0

    # Exact full query match in name — strongest signal
    if full_query in name:
        score += 100

    # Individual term matching
    for term in terms:
        # Name matches (most important)
        if term in name:
            score += 30
            # Bonus for word-boundary match (not substring of another word)
            if re.search(rf'\b{re.escape(term)}\b', name):
                score += 10

        # Tag matches (very relevant — tags are curated)
        if any(term in tag or tag in term for tag in tags):
            score += 25

        # Category match
        if term in category:
            score += 15

        # Description/id matches (weaker signal)
        if term in desc:
            score += 5
        if term in bp_id:
            score += 5

    if score == 0:
        return 0

    # Download count bonus (log scale, capped — popular builds are usually better)
    if downloads > 0:
        import math
        score += min(math.log2(downloads + 1) * 2, 20)

    return score


def inspect_schematic(blueprint_id: str) -> str:
    """Get details about a specific schematic. Returns formatted text for the LLM."""
    catalog = _load_catalog()

    for cat_data in catalog["categories"].values():
        for bp in cat_data.get("blueprints", []):
            if bp["id"] == blueprint_id:
                d = bp["dimensions"]
                lines = [
                    f"Blueprint: {bp['name']}",
                    f"ID: {bp['id']}",
                    f"Dimensions: {d['w']}W x {d['h']}H x {d['d']}D",
                    f"Block count: {bp['block_count']}",
                    f"Tags: {', '.join(bp.get('tags', []))}",
                    f"Author: {bp.get('author', 'Unknown')}",
                    f"Skill level: {bp.get('skill_level', 0)}",
                    "",
                    "Use build_schematic to construct this at a location.",
                    "The structure will appear progressively from the ground up.",
                ]
                return "\n".join(lines)

    return f"Blueprint '{blueprint_id}' not found. Use browse_schematics to see available blueprints."


def build_schematic_command(blueprint_id: str, x: int, y: int, z: int, rotation: int = 0) -> dict | None:
    """Create the special schematic build command for the plugin.

    Returns a command dict with type "build_schematic" that the plugin handles specially.
    """
    catalog = _load_catalog()

    # Validate blueprint exists
    found = False
    for cat_data in catalog["categories"].values():
        for bp in cat_data.get("blueprints", []):
            if bp["id"] == blueprint_id:
                found = True
                break
        if found:
            break

    if not found:
        logger.warning(f"Blueprint not found: {blueprint_id}")
        return None

    # Validate coordinates
    for coord in (x, y, z):
        if not isinstance(coord, int) or abs(coord) > 30000:
            logger.warning(f"Invalid coordinate for schematic build: {coord}")
            return None

    # Validate rotation
    if rotation not in (0, 90, 180, 270):
        rotation = 0

    return {
        "type": "build_schematic",
        "blueprint_id": blueprint_id,
        "x": x,
        "y": y,
        "z": z,
        "rotation": rotation,
    }
